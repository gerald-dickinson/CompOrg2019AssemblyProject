; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\gdick\source\repos\AssemblyProject\AssemblyProject\CryptoMain_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?gkey@@3PAEA					; gkey
PUBLIC	?gPassword@@3PADA				; gPassword
PUBLIC	?gPasswordHash@@3PAEA				; gPasswordHash
PUBLIC	?gdebug1@@3EA					; gdebug1
PUBLIC	?gdebug2@@3EA					; gdebug2
PUBLIC	?gfptrIn@@3PAU_iobuf@@A				; gfptrIn
PUBLIC	?gfptrOut@@3PAU_iobuf@@A			; gfptrOut
PUBLIC	?gfptrKey@@3PAU_iobuf@@A			; gfptrKey
PUBLIC	?gInFileName@@3PADA				; gInFileName
PUBLIC	?gOutFileName@@3PADA				; gOutFileName
PUBLIC	?gKeyFileName@@3PADA				; gKeyFileName
PUBLIC	?gOp@@3HA					; gOp
PUBLIC	?gNumRounds@@3HA				; gNumRounds
PUBLIC	?gEncodeTable@@3PAEA				; gEncodeTable
PUBLIC	?gDecodeTable@@3PAEA				; gDecodeTable
PUBLIC	?gptrKey@@3PAEA					; gptrKey
PUBLIC	?gptrPasswordHash@@3PAEA			; gptrPasswordHash
_BSS	SEGMENT
?gkey@@3PAEA DB	010001H DUP (?)				; gkey
	ALIGN	4

?gPasswordHash@@3PAEA DB 020H DUP (?)			; gPasswordHash
?gdebug1@@3EA DB 01H DUP (?)				; gdebug1
	ALIGN	4

?gdebug2@@3EA DB 01H DUP (?)				; gdebug2
	ALIGN	4

?gfptrIn@@3PAU_iobuf@@A DD 01H DUP (?)			; gfptrIn
?gfptrOut@@3PAU_iobuf@@A DD 01H DUP (?)			; gfptrOut
?gfptrKey@@3PAU_iobuf@@A DD 01H DUP (?)			; gfptrKey
?gInFileName@@3PADA DB 0100H DUP (?)			; gInFileName
?gOutFileName@@3PADA DB 0100H DUP (?)			; gOutFileName
?gKeyFileName@@3PADA DB 0100H DUP (?)			; gKeyFileName
?gOp@@3HA DD	01H DUP (?)				; gOp
_BSS	ENDS
msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__2088847F_corecrt_memory@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__E9FFF232_guiddef@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__12AD47BB_winuser@h DB 01H
__B4B40122_winioctl@h DB 01H
__A73354DD_stdlib@h DB 01H
__25F3FB34_propidl@h DB 01H
__A40E48B8_oleauto@h DB 01H
__86261D59_stralign@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__F0CC4AC4_corecrt_wio@h DB 01H
__014F4607_corecrt_io@h DB 01H
__C6F44F76_cryptomain_initial@cpp DB 01H
msvcjmc	ENDS
_DATA	SEGMENT
?gPassword@@3PADA DB 'password', 00H			; gPassword
	ORG $+247
?gNumRounds@@3HA DD 01H					; gNumRounds
?gptrKey@@3PAEA DD FLAT:?gkey@@3PAEA			; gptrKey
?gEncodeTable@@3PAEA DB 027H				; gEncodeTable
	DB	046H
	DB	017H
	DB	07H
	DB	03cH
	DB	0ffH
	DB	03fH
	DB	0d3H
	DB	04cH
	DB	0b2H
	DB	0c1H
	DB	0c3H
	DB	05fH
	DB	015H
	DB	04H
	DB	0efH
	DB	038H
	DB	0aeH
	DB	0eH
	DB	097H
	DB	02dH
	DB	04dH
	DB	0f8H
	DB	0c2H
	DB	035H
	DB	0daH
	DB	09fH
	DB	024H
	DB	043H
	DB	050H
	DB	09dH
	DB	045H
	DB	0d2H
	DB	0aH
	DB	078H
	DB	0e0H
	DB	03eH
	DB	018H
	DB	089H
	DB	062H
	DB	0c7H
	DB	07fH
	DB	093H
	DB	0ceH
	DB	0b4H
	DB	031H
	DB	07bH
	DB	0ccH
	DB	00H
	DB	0dbH
	DB	010H
	DB	092H
	DB	05dH
	DB	0f4H
	DB	077H
	DB	08aH
	DB	02cH
	DB	0a9H
	DB	034H
	DB	0faH
	DB	026H
	DB	01cH
	DB	0f6H
	DB	0a4H
	DB	095H
	DB	06cH
	DB	04bH
	DB	0c4H
	DB	09H
	DB	05aH
	DB	074H
	DB	0ecH
	DB	06aH
	DB	0afH
	DB	04aH
	DB	084H
	DB	063H
	DB	0dH
	DB	0aaH
	DB	014H
	DB	030H
	DB	016H
	DB	064H
	DB	06dH
	DB	058H
	DB	0d0H
	DB	0bbH
	DB	0d8H
	DB	075H
	DB	0e5H
	DB	02aH
	DB	09bH
	DB	041H
	DB	0c8H
	DB	08dH
	DB	0e6H
	DB	01H
	DB	0b1H
	DB	0a0H
	DB	0f3H
	DB	0ebH
	DB	09eH
	DB	069H
	DB	087H
	DB	037H
	DB	081H
	DB	048H
	DB	07cH
	DB	0a8H
	DB	0c0H
	DB	0f5H
	DB	0b7H
	DB	023H
	DB	0a3H
	DB	07eH
	DB	02eH
	DB	0e4H
	DB	01dH
	DB	056H
	DB	033H
	DB	03dH
	DB	0a5H
	DB	0e3H
	DB	0d1H
	DB	0bfH
	DB	055H
	DB	022H
	DB	0c6H
	DB	0c9H
	DB	0dfH
	DB	032H
	DB	09cH
	DB	0fdH
	DB	0d6H
	DB	03H
	DB	06H
	DB	05cH
	DB	08eH
	DB	0b0H
	DB	03bH
	DB	08cH
	DB	036H
	DB	04fH
	DB	02H
	DB	025H
	DB	07aH
	DB	0edH
	DB	07dH
	DB	0d5H
	DB	082H
	DB	011H
	DB	090H
	DB	0bH
	DB	0cdH
	DB	0b3H
	DB	0abH
	DB	02bH
	DB	053H
	DB	0b6H
	DB	054H
	DB	0a2H
	DB	0e8H
	DB	059H
	DB	072H
	DB	086H
	DB	083H
	DB	0caH
	DB	049H
	DB	06eH
	DB	040H
	DB	0bcH
	DB	061H
	DB	052H
	DB	0feH
	DB	079H
	DB	0eaH
	DB	029H
	DB	042H
	DB	088H
	DB	096H
	DB	0beH
	DB	012H
	DB	0cbH
	DB	0baH
	DB	08H
	DB	01eH
	DB	051H
	DB	02fH
	DB	044H
	DB	020H
	DB	065H
	DB	06bH
	DB	04eH
	DB	067H
	DB	0eeH
	DB	0a6H
	DB	071H
	DB	0dcH
	DB	076H
	DB	019H
	DB	0deH
	DB	0f2H
	DB	0fbH
	DB	070H
	DB	021H
	DB	0cfH
	DB	073H
	DB	068H
	DB	0e7H
	DB	0b9H
	DB	0f1H
	DB	05bH
	DB	091H
	DB	0d9H
	DB	0d4H
	DB	099H
	DB	01bH
	DB	0e1H
	DB	0f0H
	DB	0ddH
	DB	0fcH
	DB	0e2H
	DB	039H
	DB	05eH
	DB	01aH
	DB	066H
	DB	060H
	DB	0a7H
	DB	08bH
	DB	0b8H
	DB	0d7H
	DB	094H
	DB	0e9H
	DB	0acH
	DB	0c5H
	DB	09aH
	DB	0bdH
	DB	06fH
	DB	0f9H
	DB	028H
	DB	013H
	DB	05H
	DB	057H
	DB	0b5H
	DB	0cH
	DB	080H
	DB	08fH
	DB	03aH
	DB	01fH
	DB	047H
	DB	098H
	DB	0fH
	DB	0f7H
	DB	0adH
	DB	085H
	DB	0a1H
?gDecodeTable@@3PAEA DB 030H				; gDecodeTable
	DB	060H
	DB	08fH
	DB	086H
	DB	0eH
	DB	0f1H
	DB	087H
	DB	03H
	DB	0b8H
	DB	044H
	DB	021H
	DB	098H
	DB	0f4H
	DB	04dH
	DB	012H
	DB	0fbH
	DB	032H
	DB	096H
	DB	0b5H
	DB	0f0H
	DB	04fH
	DB	0dH
	DB	051H
	DB	02H
	DB	025H
	DB	0c7H
	DB	0e0H
	DB	0d8H
	DB	03dH
	DB	075H
	DB	0b9H
	DB	0f8H
	DB	0bdH
	DB	0ccH
	DB	07eH
	DB	070H
	DB	01bH
	DB	090H
	DB	03cH
	DB	00H
	DB	0efH
	DB	0b0H
	DB	05aH
	DB	09cH
	DB	038H
	DB	014H
	DB	073H
	DB	0bbH
	DB	050H
	DB	02dH
	DB	082H
	DB	077H
	DB	03aH
	DB	018H
	DB	08dH
	DB	068H
	DB	010H
	DB	0deH
	DB	0f7H
	DB	08bH
	DB	04H
	DB	078H
	DB	024H
	DB	06H
	DB	0a9H
	DB	05cH
	DB	0b1H
	DB	01cH
	DB	0bcH
	DB	01fH
	DB	01H
	DB	0f9H
	DB	06aH
	DB	0a7H
	DB	04aH
	DB	042H
	DB	08H
	DB	015H
	DB	0c0H
	DB	08eH
	DB	01dH
	DB	0baH
	DB	0acH
	DB	09dH
	DB	09fH
	DB	07dH
	DB	076H
	DB	0f2H
	DB	054H
	DB	0a2H
	DB	045H
	DB	0d3H
	DB	088H
	DB	034H
	DB	0dfH
	DB	0cH
	DB	0e2H
	DB	0abH
	DB	027H
	DB	04cH
	DB	052H
	DB	0beH
	DB	0e1H
	DB	0c1H
	DB	0cfH
	DB	066H
	DB	048H
	DB	0bfH
	DB	041H
	DB	053H
	DB	0a8H
	DB	0edH
	DB	0cbH
	DB	0c4H
	DB	0a3H
	DB	0ceH
	DB	046H
	DB	058H
	DB	0c6H
	DB	036H
	DB	022H
	DB	0aeH
	DB	091H
	DB	02eH
	DB	06bH
	DB	093H
	DB	072H
	DB	029H
	DB	0f5H
	DB	069H
	DB	095H
	DB	0a5H
	DB	04bH
	DB	0feH
	DB	0a4H
	DB	067H
	DB	0b2H
	DB	026H
	DB	037H
	DB	0e4H
	DB	08cH
	DB	05eH
	DB	089H
	DB	0f6H
	DB	097H
	DB	0d4H
	DB	033H
	DB	02aH
	DB	0e7H
	DB	040H
	DB	0b3H
	DB	013H
	DB	0faH
	DB	0d7H
	DB	0ebH
	DB	05bH
	DB	083H
	DB	01eH
	DB	065H
	DB	01aH
	DB	062H
	DB	0ffH
	DB	0a0H
	DB	071H
	DB	03fH
	DB	079H
	DB	0c3H
	DB	0e3H
	DB	06cH
	DB	039H
	DB	04eH
	DB	09bH
	DB	0e9H
	DB	0fdH
	DB	011H
	DB	049H
	DB	08aH
	DB	061H
	DB	09H
	DB	09aH
	DB	02cH
	DB	0f3H
	DB	09eH
	DB	06fH
	DB	0e5H
	DB	0d1H
	DB	0b7H
	DB	056H
	DB	0aaH
	DB	0ecH
	DB	0b4H
	DB	07cH
	DB	06dH
	DB	0aH
	DB	017H
	DB	0bH
	DB	043H
	DB	0eaH
	DB	07fH
	DB	028H
	DB	05dH
	DB	080H
	DB	0a6H
	DB	0b6H
	DB	02fH
	DB	099H
	DB	02bH
	DB	0cdH
	DB	055H
	DB	07bH
	DB	020H
	DB	07H
	DB	0d6H
	DB	094H
	DB	085H
	DB	0e6H
	DB	057H
	DB	0d5H
	DB	019H
	DB	031H
	DB	0c5H
	DB	0dbH
	DB	0c8H
	DB	081H
	DB	023H
	DB	0d9H
	DB	0ddH
	DB	07aH
	DB	074H
	DB	059H
	DB	05fH
	DB	0d0H
	DB	0a1H
	DB	0e8H
	DB	0afH
	DB	064H
	DB	047H
	DB	092H
	DB	0c2H
	DB	0fH
	DB	0daH
	DB	0d2H
	DB	0c9H
	DB	063H
	DB	035H
	DB	06eH
	DB	03eH
	DB	0fcH
	DB	016H
	DB	0eeH
	DB	03bH
	DB	0caH
	DB	0dcH
	DB	084H
	DB	0adH
	DB	05H
?gptrPasswordHash@@3PAEA DD FLAT:?gPasswordHash@@3PAEA	; gptrPasswordHash
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	?exCountLetters@@YAXPADHPAH11@Z			; exCountLetters
PUBLIC	?encryptFile@@YAHPAU_iobuf@@0@Z			; encryptFile
PUBLIC	?decryptFile@@YAHPAU_iobuf@@0@Z			; decryptFile
PUBLIC	?openInputFile@@YAPAU_iobuf@@PAD@Z		; openInputFile
PUBLIC	?openOutputFile@@YAPAU_iobuf@@PAD@Z		; openOutputFile
PUBLIC	?usage@@YAXQAPAD@Z				; usage
PUBLIC	?parseCommandLine@@YAXHQAPAD@Z			; parseCommandLine
PUBLIC	_main
PUBLIC	__JustMyCode_Default
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0CO@PKBMFPCH@Error?5?9?5Input?5file?5to?5encrypt?5i@ ; `string'
PUBLIC	??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5b@ ; `string'
PUBLIC	??_C@_0CO@NGFEABL@Error?5?9?5Input?5file?5to?5decrypt?5i@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5@ ; `string'
PUBLIC	??_C@_0CG@NACGJJHN@Error?5?9?5File?5size?5is?5zero?5for?5?$CC@ ; `string'
PUBLIC	??_C@_0CC@ECEBOFML@Aborting?5operation?5?9?5try?5again?$CB@ ; `string'
PUBLIC	??_C@_03BFHAFKOB@wb?$CL@			; `string'
PUBLIC	??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output@ ; `string'
PUBLIC	??_C@_0L@HKODOBAD@?6?6Usage?3?6?6@		; `string'
PUBLIC	??_C@_0N@MOPCGLHN@To?5Encrypt?3?6@		; `string'
PUBLIC	??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMke@ ; `string'
PUBLIC	??_C@_0N@KDGFJOJO@To?5Decrypt?3?6@		; `string'
PUBLIC	??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMke@ ; `string'
PUBLIC	??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5speci@ ; `string'
PUBLIC	??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5speci@ ; `string'
PUBLIC	??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5b@ ; `string'
PUBLIC	??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encryp@ ; `string'
PUBLIC	??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5outpu@ ; `string'
PUBLIC	??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irr@ ; `string'
PUBLIC	??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5b@ ; `string'
PUBLIC	??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5inpu@ ; `string'
PUBLIC	??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5@ ; `string'
PUBLIC	??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5inpu@ ; `string'
PUBLIC	??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5@ ; `string'
PUBLIC	??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outp@ ; `string'
PUBLIC	??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5@ ; `string'
PUBLIC	??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5f@ ; `string'
PUBLIC	??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5@ ; `string'
PUBLIC	??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passw@ ; `string'
PUBLIC	??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5af@ ; `string'
PUBLIC	??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5betwee@ ; `string'
PUBLIC	??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5@ ; `string'
PUBLIC	??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argume@ ; `string'
PUBLIC	??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5@ ; `string'
PUBLIC	??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4@ ; `string'
PUBLIC	??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6@ ; `string'
PUBLIC	??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8passwor@ ; `string'
PUBLIC	??_C@_04EHENEAPI@?4enc@				; `string'
PUBLIC	??_C@_04PDKEMIHM@?4dec@				; `string'
PUBLIC	??_C@_06POAFONNM@DEBAC?$AA@			; `string'
PUBLIC	??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6@ ; `string'
PUBLIC	??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corr@ ; `string'
PUBLIC	??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5no@ ; `string'
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_exit:PROC
EXTRN	_atoi:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	_fwrite:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	?sha256@@YAHPAD0KQAE@Z:PROC			; sha256
EXTRN	?encryptData@@YAHPADH@Z:PROC			; encryptData
EXTRN	?decryptData@@YAHPADH@Z:PROC			; decryptData
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5no@
CONST	SEGMENT
??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5no@ DB 'Error! L'
	DB	'ength of key file is not at least 65537.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corr@
CONST	SEGMENT
??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corr@ DB 'Error! Pas'
	DB	'sword not hashed correctly.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6@
CONST	SEGMENT
??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6@ DB 0aH, 0aH, 'Crypto Ord'
	DB	'er:%s', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06POAFONNM@DEBAC?$AA@
CONST	SEGMENT
??_C@_06POAFONNM@DEBAC?$AA@ DB 'DEBAC', 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PDKEMIHM@?4dec@
CONST	SEGMENT
??_C@_04PDKEMIHM@?4dec@ DB '.dec', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHENEAPI@?4enc@
CONST	SEGMENT
??_C@_04EHENEAPI@?4enc@ DB '.enc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8passwor@
CONST	SEGMENT
??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8passwor@ DB 'Warning! U'
	DB	'sing default ''password''.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6@
CONST	SEGMENT
??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6@ DB 'Error! '
	DB	'No key file specified.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4@
CONST	SEGMENT
??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4@ DB 'Error! No'
	DB	' input file specified.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5@
CONST	SEGMENT
??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5@ DB 'Error! En'
	DB	'crypt or Decrypt must be specified.', 0aH, 0aH, ')', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argume@
CONST	SEGMENT
??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argume@ DB 'Error! Ill'
	DB	'egal option in argument. %s', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5@
CONST	SEGMENT
??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5@ DB 'Warning! E'
	DB	'ntered bad value for number of rounds. Setting it to one.', 0aH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5betwee@
CONST	SEGMENT
??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5betwee@ DB 'Error! Mus'
	DB	't enter number between 1 and 3 after ''-r''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5af@
CONST	SEGMENT
??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5af@ DB 'Error! Mu'
	DB	'st enter a password after ''-p''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passw@
CONST	SEGMENT
??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passw@ DB 'Error! Alre'
	DB	'ady specifed a password.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5@
CONST	SEGMENT
??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5@ DB 'Error! Mu'
	DB	'st specify a filename after ''-k''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5f@
CONST	SEGMENT
??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5f@ DB 'Error! Al'
	DB	'ready specifed a key file.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5@
CONST	SEGMENT
??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5@ DB 'Error! Mu'
	DB	'st specify a filename after ''-o''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outp@
CONST	SEGMENT
??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outp@ DB 'Error! Alr'
	DB	'eady specifed an output file.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5@
CONST	SEGMENT
??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5@ DB 'Error! Mu'
	DB	'st specify a filename after ''-d''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5inpu@
CONST	SEGMENT
??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5inpu@ DB 'Error! Alr'
	DB	'eady specifed an input file - can''t decrypt/encrypt multiple'
	DB	' files.', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5@
CONST	SEGMENT
??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5@ DB 'Error! Mu'
	DB	'st specify a filename after ''-e''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5inpu@
CONST	SEGMENT
??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5inpu@ DB 'Error! Alr'
	DB	'eady specifed an input file - can''t encrypt/decrypt multiple'
	DB	' files.', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5b@
CONST	SEGMENT
??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5b@ DB 'All options '
	DB	'must be preceeded by a dash ''-''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irr@
CONST	SEGMENT
??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irr@ DB 'The order o'
	DB	'f the options is irrelevant.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5outpu@
CONST	SEGMENT
??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5outpu@ DB '-o filenam'
	DB	'e', 09H, 09H, ':name of the output file [default=''encrypted.'
	DB	'txt'' or ''decrypted.txt''', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encryp@
CONST	SEGMENT
??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encryp@ DB '-'
	DB	'r <#rounds>', 09H, 09H, ':number of encryption rounds (1 - 3)'
	DB	'  [default = 1]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5b@
CONST	SEGMENT
??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5b@ DB '-p passwo'
	DB	'rd', 09H, 09H, ':the password to be used for encryption [defa'
	DB	'ult=''password'']', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5speci@
CONST	SEGMENT
??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5speci@ DB '-d filenam'
	DB	'e', 09H, 09H, ':decrypt the specified file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5speci@
CONST	SEGMENT
??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5speci@ DB '-e filenam'
	DB	'e', 09H, 09H, ':encrypt the specified file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMke@
CONST	SEGMENT
??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMke@ DB '%'
	DB	's -d <message_filename> -k <keyfile> -p <password> [-r <#roun'
	DB	'ds>]', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDGFJOJO@To?5Decrypt?3?6@
CONST	SEGMENT
??_C@_0N@KDGFJOJO@To?5Decrypt?3?6@ DB 'To Decrypt:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMke@
CONST	SEGMENT
??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMke@ DB '%'
	DB	's -e <message_filename> -k <keyfile> -p <password> [-r <#roun'
	DB	'ds>]', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOPCGLHN@To?5Encrypt?3?6@
CONST	SEGMENT
??_C@_0N@MOPCGLHN@To?5Encrypt?3?6@ DB 'To Encrypt:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HKODOBAD@?6?6Usage?3?6?6@
CONST	SEGMENT
??_C@_0L@HKODOBAD@?6?6Usage?3?6?6@ DB 0aH, 0aH, 'Usage:', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output@
CONST	SEGMENT
??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output@ DB 0aH, 0aH, 'E'
	DB	'rror - Could not open output file %s!', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BFHAFKOB@wb?$CL@
CONST	SEGMENT
??_C@_03BFHAFKOB@wb?$CL@ DB 'wb+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ECEBOFML@Aborting?5operation?5?9?5try?5again?$CB@
CONST	SEGMENT
??_C@_0CC@ECEBOFML@Aborting?5operation?5?9?5try?5again?$CB@ DB 'Aborting '
	DB	'operation - try again!', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NACGJJHN@Error?5?9?5File?5size?5is?5zero?5for?5?$CC@
CONST	SEGMENT
??_C@_0CG@NACGJJHN@Error?5?9?5File?5size?5is?5zero?5for?5?$CC@ DB 'Error '
	DB	'- File size is zero for "%s".', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5@
CONST	SEGMENT
??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5@ DB 0aH, 0aH, 'E'
	DB	'rror - Could not open input file %s!', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@NGFEABL@Error?5?9?5Input?5file?5to?5decrypt?5i@
CONST	SEGMENT
??_C@_0CO@NGFEABL@Error?5?9?5Input?5file?5to?5decrypt?5i@ DB 'Error - Inp'
	DB	'ut file to decrypt is too large.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5b@
CONST	SEGMENT
??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5b@ DB 'Error -'
	DB	' Could not allocate %d bytes of memory on the heap.', 0aH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PKBMFPCH@Error?5?9?5Input?5file?5to?5encrypt?5i@
CONST	SEGMENT
??_C@_0CO@PKBMFPCH@Error?5?9?5Input?5file?5to?5encrypt?5i@ DB 'Error - In'
	DB	'put file to encrypt is too large.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\gdick\source\repos\assemblyproject\assemblyproject\cryptomain_initial.cpp
;	COMDAT _main
_TEXT	SEGMENT
_resulti$ = -20						; size = 4
_length$ = -8						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 459  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C6F44F76_cryptomain_initial@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 460  : #ifdef TEST_CODE
; 461  : 	char testData[] = "The big lazy brown FOX jumped 123 the 987 dog. Then he 8 a CHICKEN.";
; 462  : 	int numCAPS, numLow, numNonLetters;
; 463  : 	numCAPS = numLow = numNonLetters = 0;
; 464  : 	exCountLetters(testData, strlen(testData), &numCAPS, &numLow, &numNonLetters);
; 465  : 	printf("numCAPS=%d, numLow=%d, numNonLetters=%d\n", numCAPS, numLow, numNonLetters);
; 466  : 	exit(0);
; 467  : #endif
; 468  : 
; 469  : 	int length, resulti;
; 470  : 
; 471  : 	fprintf(stdout, "\n\nCrypto Order:%s\n\n", CRYPTO_ORDER);

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_06POAFONNM@DEBAC?$AA@
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6@
  00032	6a 01		 push	 1
  00034	e8 00 00 00 00	 call	 ___acrt_iob_func
  00039	83 c4 04	 add	 esp, 4
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _fprintf
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 472  : 
; 473  : 	// parse command line parameters
; 474  : 	parseCommandLine(argc, argv);		// sets global variables, checks input options for errors

  00045	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _argc$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ?parseCommandLine@@YAXHQAPAD@Z ; parseCommandLine
  00052	83 c4 08	 add	 esp, 8

; 475  : 
; 476  : 	// open the input and output files
; 477  : 	gfptrIn = openInputFile(gInFileName);

  00055	68 00 00 00 00	 push	 OFFSET ?gInFileName@@3PADA ; gInFileName
  0005a	e8 00 00 00 00	 call	 ?openInputFile@@YAPAU_iobuf@@PAD@Z ; openInputFile
  0005f	83 c4 04	 add	 esp, 4
  00062	a3 00 00 00 00	 mov	 DWORD PTR ?gfptrIn@@3PAU_iobuf@@A, eax ; gfptrIn

; 478  : 	gfptrKey = openInputFile(gKeyFileName);

  00067	68 00 00 00 00	 push	 OFFSET ?gKeyFileName@@3PADA ; gKeyFileName
  0006c	e8 00 00 00 00	 call	 ?openInputFile@@YAPAU_iobuf@@PAD@Z ; openInputFile
  00071	83 c4 04	 add	 esp, 4
  00074	a3 00 00 00 00	 mov	 DWORD PTR ?gfptrKey@@3PAU_iobuf@@A, eax ; gfptrKey

; 479  : 	gfptrOut = openOutputFile(gOutFileName);

  00079	68 00 00 00 00	 push	 OFFSET ?gOutFileName@@3PADA ; gOutFileName
  0007e	e8 00 00 00 00	 call	 ?openOutputFile@@YAPAU_iobuf@@PAD@Z ; openOutputFile
  00083	83 c4 04	 add	 esp, 4
  00086	a3 00 00 00 00	 mov	 DWORD PTR ?gfptrOut@@3PAU_iobuf@@A, eax ; gfptrOut

; 480  : 
; 481  : 	length = (size_t)strlen(gPassword);

  0008b	68 00 00 00 00	 push	 OFFSET ?gPassword@@3PADA ; gPassword
  00090	e8 00 00 00 00	 call	 _strlen
  00095	83 c4 04	 add	 esp, 4
  00098	89 45 f8	 mov	 DWORD PTR _length$[ebp], eax

; 482  : 
; 483  : 	resulti = sha256(NULL, gPassword, length, gPasswordHash);		// get sha-256 hash of password

  0009b	68 00 00 00 00	 push	 OFFSET ?gPasswordHash@@3PAEA ; gPasswordHash
  000a0	8b 45 f8	 mov	 eax, DWORD PTR _length$[ebp]
  000a3	50		 push	 eax
  000a4	68 00 00 00 00	 push	 OFFSET ?gPassword@@3PADA ; gPassword
  000a9	6a 00		 push	 0
  000ab	e8 00 00 00 00	 call	 ?sha256@@YAHPAD0KQAE@Z	; sha256
  000b0	83 c4 10	 add	 esp, 16			; 00000010H
  000b3	89 45 ec	 mov	 DWORD PTR _resulti$[ebp], eax

; 484  : 	if (resulti != 0)

  000b6	83 7d ec 00	 cmp	 DWORD PTR _resulti$[ebp], 0
  000ba	74 1f		 je	 SHORT $LN2@main

; 485  : 	{
; 486  : 		fprintf(stderr, "Error! Password not hashed correctly.\n\n");

  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corr@
  000c1	6a 02		 push	 2
  000c3	e8 00 00 00 00	 call	 ___acrt_iob_func
  000c8	83 c4 04	 add	 esp, 4
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _fprintf
  000d1	83 c4 08	 add	 esp, 8

; 487  : 		exit(-1);

  000d4	6a ff		 push	 -1
  000d6	e8 00 00 00 00	 call	 _exit
$LN2@main:

; 488  : 	}
; 489  : 
; 490  : 	length = fread(gkey, 1, 65537, gfptrKey);

  000db	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrKey@@3PAU_iobuf@@A ; gfptrKey
  000e0	50		 push	 eax
  000e1	68 01 00 01 00	 push	 65537			; 00010001H
  000e6	6a 01		 push	 1
  000e8	68 00 00 00 00	 push	 OFFSET ?gkey@@3PAEA	; gkey
  000ed	e8 00 00 00 00	 call	 _fread
  000f2	83 c4 10	 add	 esp, 16			; 00000010H
  000f5	89 45 f8	 mov	 DWORD PTR _length$[ebp], eax

; 491  : 	if (length != 65537)

  000f8	81 7d f8 01 00
	01 00		 cmp	 DWORD PTR _length$[ebp], 65537 ; 00010001H
  000ff	74 1f		 je	 SHORT $LN3@main

; 492  : 	{
; 493  : 		fprintf(stderr, "Error! Length of key file is not at least 65537.\n\n");

  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5no@
  00106	6a 02		 push	 2
  00108	e8 00 00 00 00	 call	 ___acrt_iob_func
  0010d	83 c4 04	 add	 esp, 4
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _fprintf
  00116	83 c4 08	 add	 esp, 8

; 494  : 		exit(-1);

  00119	6a ff		 push	 -1
  0011b	e8 00 00 00 00	 call	 _exit
$LN3@main:

; 495  : 	}
; 496  : 	fclose(gfptrKey);

  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrKey@@3PAU_iobuf@@A ; gfptrKey
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _fclose
  0012b	83 c4 04	 add	 esp, 4

; 497  : 	gfptrKey = NULL;

  0012e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gfptrKey@@3PAU_iobuf@@A, 0 ; gfptrKey

; 498  : 
; 499  : 	if (gOp == 1)	// encrypt

  00138	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gOp@@3HA, 1	; gOp
  0013f	75 17		 jne	 SHORT $LN4@main

; 500  : 	{
; 501  : 		encryptFile(gfptrIn, gfptrOut);

  00141	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrOut@@3PAU_iobuf@@A ; gfptrOut
  00146	50		 push	 eax
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gfptrIn@@3PAU_iobuf@@A ; gfptrIn
  0014d	51		 push	 ecx
  0014e	e8 00 00 00 00	 call	 ?encryptFile@@YAHPAU_iobuf@@0@Z ; encryptFile
  00153	83 c4 08	 add	 esp, 8

; 502  : 	}
; 503  : 	else

  00156	eb 15		 jmp	 SHORT $LN5@main
$LN4@main:

; 504  : 	{
; 505  : 		decryptFile(gfptrIn, gfptrOut);

  00158	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrOut@@3PAU_iobuf@@A ; gfptrOut
  0015d	50		 push	 eax
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gfptrIn@@3PAU_iobuf@@A ; gfptrIn
  00164	51		 push	 ecx
  00165	e8 00 00 00 00	 call	 ?decryptFile@@YAHPAU_iobuf@@0@Z ; decryptFile
  0016a	83 c4 08	 add	 esp, 8
$LN5@main:

; 506  : 	}
; 507  : 
; 508  : 	fclose(gfptrIn);

  0016d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrIn@@3PAU_iobuf@@A ; gfptrIn
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _fclose
  00178	83 c4 04	 add	 esp, 4

; 509  : 	fclose(gfptrOut);

  0017b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrOut@@3PAU_iobuf@@A ; gfptrOut
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 _fclose
  00186	83 c4 04	 add	 esp, 4

; 510  : 	return 0;

  00189	33 c0		 xor	 eax, eax
$LN6@main:

; 511  : } // main

  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
  0018d	5b		 pop	 ebx
  0018e	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00194	3b ec		 cmp	 ebp, esp
  00196	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\gdick\source\repos\assemblyproject\assemblyproject\cryptomain_initial.cpp
;	COMDAT ?parseCommandLine@@YAXHQAPAD@Z
_TEXT	SEGMENT
_x$1 = -92						; size = 4
_err_flag$ = -77					; size = 1
_p_flag$ = -65						; size = 1
_k_flag$ = -53						; size = 1
_o_flag$ = -41						; size = 1
_i_flag$ = -29						; size = 1
_ch$ = -17						; size = 1
_cnt$ = -8						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
?parseCommandLine@@YAXHQAPAD@Z PROC			; parseCommandLine, COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C6F44F76_cryptomain_initial@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 274  : 	int cnt;
; 275  : 	char ch;
; 276  : 	bool i_flag, o_flag, k_flag, p_flag, err_flag;
; 277  : 
; 278  : 	i_flag = k_flag = false;				// these must be true in order to exit this function

  00028	c6 45 cb 00	 mov	 BYTE PTR _k_flag$[ebp], 0
  0002c	8a 45 cb	 mov	 al, BYTE PTR _k_flag$[ebp]
  0002f	88 45 e3	 mov	 BYTE PTR _i_flag$[ebp], al

; 279  : 	err_flag = p_flag = o_flag = false;		// these will generate different actions

  00032	c6 45 d7 00	 mov	 BYTE PTR _o_flag$[ebp], 0
  00036	8a 45 d7	 mov	 al, BYTE PTR _o_flag$[ebp]
  00039	88 45 bf	 mov	 BYTE PTR _p_flag$[ebp], al
  0003c	8a 4d bf	 mov	 cl, BYTE PTR _p_flag$[ebp]
  0003f	88 4d b3	 mov	 BYTE PTR _err_flag$[ebp], cl

; 280  : 
; 281  : 	cnt = 1;	// skip program name

  00042	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 1
$LN2@parseComma:

; 282  : 	while (cnt < argc)

  00049	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  0004c	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  0004f	0f 8d 57 04 00
	00		 jge	 $LN3@parseComma

; 283  : 	{
; 284  : 		ch = *argv[cnt];

  00055	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  0005b	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0005e	8a 02		 mov	 al, BYTE PTR [edx]
  00060	88 45 ef	 mov	 BYTE PTR _ch$[ebp], al

; 285  : 		if (ch != '-')

  00063	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  00067	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0006a	74 24		 je	 SHORT $LN4@parseComma

; 286  : 		{
; 287  : 			fprintf(stderr, "All options must be preceeded by a dash '-'\n\n");

  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5b@
  00071	6a 02		 push	 2
  00073	e8 00 00 00 00	 call	 ___acrt_iob_func
  00078	83 c4 04	 add	 esp, 4
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _fprintf
  00081	83 c4 08	 add	 esp, 8

; 288  : 			usage(argv);

  00084	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  0008d	83 c4 04	 add	 esp, 4
$LN4@parseComma:

; 289  : 		}
; 290  : 
; 291  : 		ch = *(argv[cnt] + 1);

  00090	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00093	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00096	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00099	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  0009c	88 45 ef	 mov	 BYTE PTR _ch$[ebp], al

; 292  : 		if (0)

  0009f	33 c0		 xor	 eax, eax
  000a1	74 05		 je	 SHORT $LN5@parseComma
  000a3	e9 f6 03 00 00	 jmp	 $LN6@parseComma
$LN5@parseComma:

; 293  : 		{
; 294  : 		}
; 295  : 
; 296  : 		else if (ch == 'e' || ch == 'E')

  000a8	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  000ac	83 f8 65	 cmp	 eax, 101		; 00000065H
  000af	74 0d		 je	 SHORT $LN9@parseComma
  000b1	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  000b5	83 f8 45	 cmp	 eax, 69			; 00000045H
  000b8	0f 85 9a 00 00
	00		 jne	 $LN7@parseComma
$LN9@parseComma:

; 297  : 		{
; 298  : 			if (i_flag == true || gOp != 0)

  000be	0f b6 45 e3	 movzx	 eax, BYTE PTR _i_flag$[ebp]
  000c2	83 f8 01	 cmp	 eax, 1
  000c5	74 09		 je	 SHORT $LN11@parseComma
  000c7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gOp@@3HA, 0	; gOp
  000ce	74 24		 je	 SHORT $LN10@parseComma
$LN11@parseComma:

; 299  : 			{
; 300  : 				fprintf(stderr, "Error! Already specifed an input file - can't encrypt/decrypt multiple files.\n\n");

  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5inpu@
  000d5	6a 02		 push	 2
  000d7	e8 00 00 00 00	 call	 ___acrt_iob_func
  000dc	83 c4 04	 add	 esp, 4
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _fprintf
  000e5	83 c4 08	 add	 esp, 8

; 301  : 				usage(argv);

  000e8	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  000f1	83 c4 04	 add	 esp, 4
$LN10@parseComma:

; 302  : 			}
; 303  : 
; 304  : 			i_flag = true;

  000f4	c6 45 e3 01	 mov	 BYTE PTR _i_flag$[ebp], 1

; 305  : 			cnt++;

  000f8	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  000fb	83 c0 01	 add	 eax, 1
  000fe	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 306  : 			if (cnt >= argc)

  00101	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00104	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  00107	7c 24		 jl	 SHORT $LN12@parseComma

; 307  : 			{
; 308  : 				fprintf(stderr, "Error! Must specify a filename after '-e'\n\n");

  00109	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5@
  0010e	6a 02		 push	 2
  00110	e8 00 00 00 00	 call	 ___acrt_iob_func
  00115	83 c4 04	 add	 esp, 4
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 _fprintf
  0011e	83 c4 08	 add	 esp, 8

; 309  : 				usage(argv);

  00121	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  0012a	83 c4 04	 add	 esp, 4
$LN12@parseComma:

; 310  : 			}
; 311  : 
; 312  : 			strncpy(gInFileName, argv[cnt], 256);

  0012d	68 00 01 00 00	 push	 256			; 00000100H
  00132	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00135	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00138	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0013b	52		 push	 edx
  0013c	68 00 00 00 00	 push	 OFFSET ?gInFileName@@3PADA ; gInFileName
  00141	e8 00 00 00 00	 call	 _strncpy
  00146	83 c4 0c	 add	 esp, 12			; 0000000cH

; 313  : 			gOp = 1;	// encrypt

  00149	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gOp@@3HA, 1	; gOp
  00153	e9 46 03 00 00	 jmp	 $LN6@parseComma
$LN7@parseComma:

; 314  : 		}
; 315  : 
; 316  : 		else if (ch == 'd' || ch == 'D')

  00158	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  0015c	83 f8 64	 cmp	 eax, 100		; 00000064H
  0015f	74 0d		 je	 SHORT $LN15@parseComma
  00161	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  00165	83 f8 44	 cmp	 eax, 68			; 00000044H
  00168	0f 85 9a 00 00
	00		 jne	 $LN13@parseComma
$LN15@parseComma:

; 317  : 		{
; 318  : 			if (i_flag == true || gOp != 0)

  0016e	0f b6 45 e3	 movzx	 eax, BYTE PTR _i_flag$[ebp]
  00172	83 f8 01	 cmp	 eax, 1
  00175	74 09		 je	 SHORT $LN17@parseComma
  00177	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gOp@@3HA, 0	; gOp
  0017e	74 24		 je	 SHORT $LN16@parseComma
$LN17@parseComma:

; 319  : 			{
; 320  : 				fprintf(stderr, "Error! Already specifed an input file - can't decrypt/encrypt multiple files.\n\n");

  00180	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5inpu@
  00185	6a 02		 push	 2
  00187	e8 00 00 00 00	 call	 ___acrt_iob_func
  0018c	83 c4 04	 add	 esp, 4
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 _fprintf
  00195	83 c4 08	 add	 esp, 8

; 321  : 				usage(argv);

  00198	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  001a1	83 c4 04	 add	 esp, 4
$LN16@parseComma:

; 322  : 			}
; 323  : 
; 324  : 			i_flag = true;

  001a4	c6 45 e3 01	 mov	 BYTE PTR _i_flag$[ebp], 1

; 325  : 			cnt++;

  001a8	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  001ab	83 c0 01	 add	 eax, 1
  001ae	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 326  : 			if (cnt >= argc)

  001b1	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  001b4	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  001b7	7c 24		 jl	 SHORT $LN18@parseComma

; 327  : 			{
; 328  : 				fprintf(stderr, "Error! Must specify a filename after '-d'\n\n");

  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5@
  001be	6a 02		 push	 2
  001c0	e8 00 00 00 00	 call	 ___acrt_iob_func
  001c5	83 c4 04	 add	 esp, 4
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 _fprintf
  001ce	83 c4 08	 add	 esp, 8

; 329  : 				usage(argv);

  001d1	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  001da	83 c4 04	 add	 esp, 4
$LN18@parseComma:

; 330  : 			}
; 331  : 
; 332  : 			strncpy(gInFileName, argv[cnt], 256);

  001dd	68 00 01 00 00	 push	 256			; 00000100H
  001e2	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  001e5	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  001e8	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  001eb	52		 push	 edx
  001ec	68 00 00 00 00	 push	 OFFSET ?gInFileName@@3PADA ; gInFileName
  001f1	e8 00 00 00 00	 call	 _strncpy
  001f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 333  : 			gOp = 2;	// decrypt

  001f9	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?gOp@@3HA, 2	; gOp
  00203	e9 96 02 00 00	 jmp	 $LN6@parseComma
$LN13@parseComma:

; 334  : 		}
; 335  : 
; 336  : 		else if (ch == 'o' || ch == 'O')

  00208	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  0020c	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  0020f	74 0d		 je	 SHORT $LN21@parseComma
  00211	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  00215	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  00218	0f 85 87 00 00
	00		 jne	 $LN19@parseComma
$LN21@parseComma:

; 337  : 		{
; 338  : 			if (o_flag == true)

  0021e	0f b6 45 d7	 movzx	 eax, BYTE PTR _o_flag$[ebp]
  00222	83 f8 01	 cmp	 eax, 1
  00225	75 24		 jne	 SHORT $LN22@parseComma

; 339  : 			{
; 340  : 				fprintf(stderr, "Error! Already specifed an output file.\n\n");

  00227	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outp@
  0022c	6a 02		 push	 2
  0022e	e8 00 00 00 00	 call	 ___acrt_iob_func
  00233	83 c4 04	 add	 esp, 4
  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 _fprintf
  0023c	83 c4 08	 add	 esp, 8

; 341  : 				usage(argv);

  0023f	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00242	50		 push	 eax
  00243	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  00248	83 c4 04	 add	 esp, 4
$LN22@parseComma:

; 342  : 			}
; 343  : 			o_flag = true;

  0024b	c6 45 d7 01	 mov	 BYTE PTR _o_flag$[ebp], 1

; 344  : 			cnt++;

  0024f	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00252	83 c0 01	 add	 eax, 1
  00255	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 345  : 			if (cnt >= argc)

  00258	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  0025b	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  0025e	7c 24		 jl	 SHORT $LN23@parseComma

; 346  : 			{
; 347  : 				fprintf(stderr, "Error! Must specify a filename after '-o'\n\n");

  00260	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5@
  00265	6a 02		 push	 2
  00267	e8 00 00 00 00	 call	 ___acrt_iob_func
  0026c	83 c4 04	 add	 esp, 4
  0026f	50		 push	 eax
  00270	e8 00 00 00 00	 call	 _fprintf
  00275	83 c4 08	 add	 esp, 8

; 348  : 				usage(argv);

  00278	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  0027b	50		 push	 eax
  0027c	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  00281	83 c4 04	 add	 esp, 4
$LN23@parseComma:

; 349  : 			}
; 350  : 			strncpy(gOutFileName, argv[cnt], 256);

  00284	68 00 01 00 00	 push	 256			; 00000100H
  00289	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  0028c	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  0028f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00292	52		 push	 edx
  00293	68 00 00 00 00	 push	 OFFSET ?gOutFileName@@3PADA ; gOutFileName
  00298	e8 00 00 00 00	 call	 _strncpy
  0029d	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a0	e9 f9 01 00 00	 jmp	 $LN6@parseComma
$LN19@parseComma:

; 351  : 		}
; 352  : 
; 353  : 		else if (ch == 'k' || ch == 'K')

  002a5	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  002a9	83 f8 6b	 cmp	 eax, 107		; 0000006bH
  002ac	74 0d		 je	 SHORT $LN26@parseComma
  002ae	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  002b2	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  002b5	0f 85 87 00 00
	00		 jne	 $LN24@parseComma
$LN26@parseComma:

; 354  : 		{
; 355  : 			if (k_flag == true)

  002bb	0f b6 45 cb	 movzx	 eax, BYTE PTR _k_flag$[ebp]
  002bf	83 f8 01	 cmp	 eax, 1
  002c2	75 24		 jne	 SHORT $LN27@parseComma

; 356  : 			{
; 357  : 				fprintf(stderr, "Error! Already specifed a key file.\n\n");

  002c4	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5f@
  002c9	6a 02		 push	 2
  002cb	e8 00 00 00 00	 call	 ___acrt_iob_func
  002d0	83 c4 04	 add	 esp, 4
  002d3	50		 push	 eax
  002d4	e8 00 00 00 00	 call	 _fprintf
  002d9	83 c4 08	 add	 esp, 8

; 358  : 				usage(argv);

  002dc	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  002df	50		 push	 eax
  002e0	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  002e5	83 c4 04	 add	 esp, 4
$LN27@parseComma:

; 359  : 			}
; 360  : 			k_flag = true;

  002e8	c6 45 cb 01	 mov	 BYTE PTR _k_flag$[ebp], 1

; 361  : 			cnt++;

  002ec	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  002ef	83 c0 01	 add	 eax, 1
  002f2	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 362  : 			if (cnt >= argc)

  002f5	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  002f8	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  002fb	7c 24		 jl	 SHORT $LN28@parseComma

; 363  : 			{
; 364  : 				fprintf(stderr, "Error! Must specify a filename after '-k'\n\n");

  002fd	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5@
  00302	6a 02		 push	 2
  00304	e8 00 00 00 00	 call	 ___acrt_iob_func
  00309	83 c4 04	 add	 esp, 4
  0030c	50		 push	 eax
  0030d	e8 00 00 00 00	 call	 _fprintf
  00312	83 c4 08	 add	 esp, 8

; 365  : 				usage(argv);

  00315	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00318	50		 push	 eax
  00319	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  0031e	83 c4 04	 add	 esp, 4
$LN28@parseComma:

; 366  : 			}
; 367  : 			strncpy(gKeyFileName, argv[cnt], 256);

  00321	68 00 01 00 00	 push	 256			; 00000100H
  00326	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00329	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  0032c	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0032f	52		 push	 edx
  00330	68 00 00 00 00	 push	 OFFSET ?gKeyFileName@@3PADA ; gKeyFileName
  00335	e8 00 00 00 00	 call	 _strncpy
  0033a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0033d	e9 5c 01 00 00	 jmp	 $LN6@parseComma
$LN24@parseComma:

; 368  : 		}
; 369  : 
; 370  : 		else if (ch == 'p' || ch == 'P')

  00342	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  00346	83 f8 70	 cmp	 eax, 112		; 00000070H
  00349	74 0d		 je	 SHORT $LN31@parseComma
  0034b	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  0034f	83 f8 50	 cmp	 eax, 80			; 00000050H
  00352	0f 85 87 00 00
	00		 jne	 $LN29@parseComma
$LN31@parseComma:

; 371  : 		{
; 372  : 			if (p_flag == true)

  00358	0f b6 45 bf	 movzx	 eax, BYTE PTR _p_flag$[ebp]
  0035c	83 f8 01	 cmp	 eax, 1
  0035f	75 24		 jne	 SHORT $LN32@parseComma

; 373  : 			{
; 374  : 				fprintf(stderr, "Error! Already specifed a password.\n\n");

  00361	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passw@
  00366	6a 02		 push	 2
  00368	e8 00 00 00 00	 call	 ___acrt_iob_func
  0036d	83 c4 04	 add	 esp, 4
  00370	50		 push	 eax
  00371	e8 00 00 00 00	 call	 _fprintf
  00376	83 c4 08	 add	 esp, 8

; 375  : 				usage(argv);

  00379	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  0037c	50		 push	 eax
  0037d	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  00382	83 c4 04	 add	 esp, 4
$LN32@parseComma:

; 376  : 			}
; 377  : 			p_flag = true;

  00385	c6 45 bf 01	 mov	 BYTE PTR _p_flag$[ebp], 1

; 378  : 			cnt++;

  00389	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  0038c	83 c0 01	 add	 eax, 1
  0038f	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 379  : 			if (cnt >= argc)

  00392	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00395	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  00398	7c 24		 jl	 SHORT $LN33@parseComma

; 380  : 			{
; 381  : 				fprintf(stderr, "Error! Must enter a password after '-p'\n\n");

  0039a	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5af@
  0039f	6a 02		 push	 2
  003a1	e8 00 00 00 00	 call	 ___acrt_iob_func
  003a6	83 c4 04	 add	 esp, 4
  003a9	50		 push	 eax
  003aa	e8 00 00 00 00	 call	 _fprintf
  003af	83 c4 08	 add	 esp, 8

; 382  : 				usage(argv);

  003b2	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  003b5	50		 push	 eax
  003b6	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  003bb	83 c4 04	 add	 esp, 4
$LN33@parseComma:

; 383  : 			}
; 384  : 			strncpy(gPassword, argv[cnt], 256);

  003be	68 00 01 00 00	 push	 256			; 00000100H
  003c3	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  003c6	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  003c9	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  003cc	52		 push	 edx
  003cd	68 00 00 00 00	 push	 OFFSET ?gPassword@@3PADA ; gPassword
  003d2	e8 00 00 00 00	 call	 _strncpy
  003d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003da	e9 bf 00 00 00	 jmp	 $LN6@parseComma
$LN29@parseComma:

; 385  : 		}
; 386  : 
; 387  : 		else if (ch == 'r' || ch == 'R')

  003df	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  003e3	83 f8 72	 cmp	 eax, 114		; 00000072H
  003e6	74 09		 je	 SHORT $LN36@parseComma
  003e8	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  003ec	83 f8 52	 cmp	 eax, 82			; 00000052H
  003ef	75 7f		 jne	 SHORT $LN34@parseComma
$LN36@parseComma:

; 388  : 		{
; 389  : 			int x;
; 390  : 
; 391  : 			cnt++;

  003f1	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  003f4	83 c0 01	 add	 eax, 1
  003f7	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 392  : 			if (cnt >= argc)

  003fa	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  003fd	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  00400	7c 24		 jl	 SHORT $LN37@parseComma

; 393  : 			{
; 394  : 				fprintf(stderr, "Error! Must enter number between 1 and 3 after '-r'\n\n");

  00402	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5betwee@
  00407	6a 02		 push	 2
  00409	e8 00 00 00 00	 call	 ___acrt_iob_func
  0040e	83 c4 04	 add	 esp, 4
  00411	50		 push	 eax
  00412	e8 00 00 00 00	 call	 _fprintf
  00417	83 c4 08	 add	 esp, 8

; 395  : 				usage(argv);

  0041a	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  00423	83 c4 04	 add	 esp, 4
$LN37@parseComma:

; 396  : 			}
; 397  : 			x = atoi(argv[cnt]);

  00426	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00429	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  0042c	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0042f	52		 push	 edx
  00430	e8 00 00 00 00	 call	 _atoi
  00435	83 c4 04	 add	 esp, 4
  00438	89 45 a4	 mov	 DWORD PTR _x$1[ebp], eax

; 398  : 			if (x < 1 || x > 3)

  0043b	83 7d a4 01	 cmp	 DWORD PTR _x$1[ebp], 1
  0043f	7c 06		 jl	 SHORT $LN39@parseComma
  00441	83 7d a4 03	 cmp	 DWORD PTR _x$1[ebp], 3
  00445	7e 1f		 jle	 SHORT $LN38@parseComma
$LN39@parseComma:

; 399  : 			{
; 400  : 				fprintf(stderr, "Warning! Entered bad value for number of rounds. Setting it to one.\n\n");

  00447	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5@
  0044c	6a 02		 push	 2
  0044e	e8 00 00 00 00	 call	 ___acrt_iob_func
  00453	83 c4 04	 add	 esp, 4
  00456	50		 push	 eax
  00457	e8 00 00 00 00	 call	 _fprintf
  0045c	83 c4 08	 add	 esp, 8

; 401  : 				x = 1;

  0045f	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 1
$LN38@parseComma:

; 402  : 			}
; 403  : 			gNumRounds = x;

  00466	8b 45 a4	 mov	 eax, DWORD PTR _x$1[ebp]
  00469	a3 00 00 00 00	 mov	 DWORD PTR ?gNumRounds@@3HA, eax ; gNumRounds

; 404  : 		}
; 405  : 
; 406  : 		else

  0046e	eb 2e		 jmp	 SHORT $LN6@parseComma
$LN34@parseComma:

; 407  : 		{
; 408  : 			fprintf(stderr, "Error! Illegal option in argument. %s\n\n", argv[cnt]);

  00470	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00473	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00476	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00479	52		 push	 edx
  0047a	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argume@
  0047f	6a 02		 push	 2
  00481	e8 00 00 00 00	 call	 ___acrt_iob_func
  00486	83 c4 04	 add	 esp, 4
  00489	50		 push	 eax
  0048a	e8 00 00 00 00	 call	 _fprintf
  0048f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 409  : 			usage(argv);

  00492	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00495	50		 push	 eax
  00496	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  0049b	83 c4 04	 add	 esp, 4
$LN6@parseComma:

; 410  : 		}
; 411  : 
; 412  : 		cnt++;

  0049e	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  004a1	83 c0 01	 add	 eax, 1
  004a4	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 413  : 	} // end while

  004a7	e9 9d fb ff ff	 jmp	 $LN2@parseComma
$LN3@parseComma:

; 414  : 
; 415  : 	if (gOp == 0)

  004ac	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gOp@@3HA, 0	; gOp
  004b3	75 1c		 jne	 SHORT $LN40@parseComma

; 416  : 	{
; 417  : 		fprintf(stderr, "Error! Encrypt or Decrypt must be specified.\n\n)");

  004b5	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5@
  004ba	6a 02		 push	 2
  004bc	e8 00 00 00 00	 call	 ___acrt_iob_func
  004c1	83 c4 04	 add	 esp, 4
  004c4	50		 push	 eax
  004c5	e8 00 00 00 00	 call	 _fprintf
  004ca	83 c4 08	 add	 esp, 8

; 418  : 		err_flag = true;

  004cd	c6 45 b3 01	 mov	 BYTE PTR _err_flag$[ebp], 1
$LN40@parseComma:

; 419  : 	}
; 420  : 
; 421  : 	if (i_flag == false)

  004d1	0f b6 45 e3	 movzx	 eax, BYTE PTR _i_flag$[ebp]
  004d5	85 c0		 test	 eax, eax
  004d7	75 1c		 jne	 SHORT $LN41@parseComma

; 422  : 	{
; 423  : 		fprintf(stderr, "Error! No input file specified.\n\n");

  004d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4@
  004de	6a 02		 push	 2
  004e0	e8 00 00 00 00	 call	 ___acrt_iob_func
  004e5	83 c4 04	 add	 esp, 4
  004e8	50		 push	 eax
  004e9	e8 00 00 00 00	 call	 _fprintf
  004ee	83 c4 08	 add	 esp, 8

; 424  : 		err_flag = true;

  004f1	c6 45 b3 01	 mov	 BYTE PTR _err_flag$[ebp], 1
$LN41@parseComma:

; 425  : 	}
; 426  : 
; 427  : 	if (k_flag == false)

  004f5	0f b6 45 cb	 movzx	 eax, BYTE PTR _k_flag$[ebp]
  004f9	85 c0		 test	 eax, eax
  004fb	75 1c		 jne	 SHORT $LN42@parseComma

; 428  : 	{
; 429  : 		fprintf(stderr, "Error! No key file specified.\n\n");

  004fd	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6@
  00502	6a 02		 push	 2
  00504	e8 00 00 00 00	 call	 ___acrt_iob_func
  00509	83 c4 04	 add	 esp, 4
  0050c	50		 push	 eax
  0050d	e8 00 00 00 00	 call	 _fprintf
  00512	83 c4 08	 add	 esp, 8

; 430  : 		err_flag = true;

  00515	c6 45 b3 01	 mov	 BYTE PTR _err_flag$[ebp], 1
$LN42@parseComma:

; 431  : 	}
; 432  : 
; 433  : 	if (p_flag == false)

  00519	0f b6 45 bf	 movzx	 eax, BYTE PTR _p_flag$[ebp]
  0051d	85 c0		 test	 eax, eax
  0051f	75 18		 jne	 SHORT $LN43@parseComma

; 434  : 	{
; 435  : 		fprintf(stderr, "Warning! Using default 'password'.\n\n");

  00521	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8passwor@
  00526	6a 02		 push	 2
  00528	e8 00 00 00 00	 call	 ___acrt_iob_func
  0052d	83 c4 04	 add	 esp, 4
  00530	50		 push	 eax
  00531	e8 00 00 00 00	 call	 _fprintf
  00536	83 c4 08	 add	 esp, 8
$LN43@parseComma:

; 436  : 	}
; 437  : 
; 438  : 	if (o_flag == false && err_flag == false)	// no need to do this if we have errors

  00539	0f b6 45 d7	 movzx	 eax, BYTE PTR _o_flag$[ebp]
  0053d	85 c0		 test	 eax, eax
  0053f	75 50		 jne	 SHORT $LN44@parseComma
  00541	0f b6 45 b3	 movzx	 eax, BYTE PTR _err_flag$[ebp]
  00545	85 c0		 test	 eax, eax
  00547	75 48		 jne	 SHORT $LN44@parseComma

; 439  : 	{
; 440  : 		strcpy(gOutFileName, gInFileName);

  00549	68 00 00 00 00	 push	 OFFSET ?gInFileName@@3PADA ; gInFileName
  0054e	68 00 00 00 00	 push	 OFFSET ?gOutFileName@@3PADA ; gOutFileName
  00553	e8 00 00 00 00	 call	 _strcpy
  00558	83 c4 08	 add	 esp, 8

; 441  : 		if (gOp == 1)	// encrypt

  0055b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gOp@@3HA, 1	; gOp
  00562	75 12		 jne	 SHORT $LN45@parseComma

; 442  : 		{
; 443  : 			strcat(gOutFileName, ".enc");

  00564	68 00 00 00 00	 push	 OFFSET ??_C@_04EHENEAPI@?4enc@
  00569	68 00 00 00 00	 push	 OFFSET ?gOutFileName@@3PADA ; gOutFileName
  0056e	e8 00 00 00 00	 call	 _strcat
  00573	83 c4 08	 add	 esp, 8
$LN45@parseComma:

; 444  : 		}
; 445  : 		if (gOp == 2)	// decrypt

  00576	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?gOp@@3HA, 2	; gOp
  0057d	75 12		 jne	 SHORT $LN44@parseComma

; 446  : 		{
; 447  : 			strcat(gOutFileName, ".dec");

  0057f	68 00 00 00 00	 push	 OFFSET ??_C@_04PDKEMIHM@?4dec@
  00584	68 00 00 00 00	 push	 OFFSET ?gOutFileName@@3PADA ; gOutFileName
  00589	e8 00 00 00 00	 call	 _strcat
  0058e	83 c4 08	 add	 esp, 8
$LN44@parseComma:

; 448  : 		}
; 449  : 	}
; 450  : 
; 451  : 	if (err_flag)

  00591	0f b6 45 b3	 movzx	 eax, BYTE PTR _err_flag$[ebp]
  00595	85 c0		 test	 eax, eax
  00597	74 0c		 je	 SHORT $LN1@parseComma

; 452  : 	{
; 453  : 		usage(argv);

  00599	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  0059c	50		 push	 eax
  0059d	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  005a2	83 c4 04	 add	 esp, 4
$LN1@parseComma:

; 454  : 	}
; 455  : 	return;
; 456  : } // parseCommandLine

  005a5	5f		 pop	 edi
  005a6	5e		 pop	 esi
  005a7	5b		 pop	 ebx
  005a8	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  005ae	3b ec		 cmp	 ebp, esp
  005b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005b5	8b e5		 mov	 esp, ebp
  005b7	5d		 pop	 ebp
  005b8	c3		 ret	 0
?parseCommandLine@@YAXHQAPAD@Z ENDP			; parseCommandLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\gdick\source\repos\assemblyproject\assemblyproject\cryptomain_initial.cpp
;	COMDAT ?usage@@YAXQAPAD@Z
_TEXT	SEGMENT
_argv$ = 8						; size = 4
?usage@@YAXQAPAD@Z PROC					; usage, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C6F44F76_cryptomain_initial@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 255  : 	printf("\n\nUsage:\n\n");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HKODOBAD@?6?6Usage?3?6?6@
  0002d	e8 00 00 00 00	 call	 _printf
  00032	83 c4 04	 add	 esp, 4

; 256  : 
; 257  : 	printf("To Encrypt:\n");

  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MOPCGLHN@To?5Encrypt?3?6@
  0003a	e8 00 00 00 00	 call	 _printf
  0003f	83 c4 04	 add	 esp, 4

; 258  : 	printf("%s -e <message_filename> -k <keyfile> -p <password> [-r <#rounds>]\n\n", argv[0]);

  00042	b8 04 00 00 00	 mov	 eax, 4
  00047	6b c8 00	 imul	 ecx, eax, 0
  0004a	8b 55 08	 mov	 edx, DWORD PTR _argv$[ebp]
  0004d	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00050	50		 push	 eax
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMke@
  00056	e8 00 00 00 00	 call	 _printf
  0005b	83 c4 08	 add	 esp, 8

; 259  : 
; 260  : 	printf("To Decrypt:\n");

  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KDGFJOJO@To?5Decrypt?3?6@
  00063	e8 00 00 00 00	 call	 _printf
  00068	83 c4 04	 add	 esp, 4

; 261  : 	printf("%s -d <message_filename> -k <keyfile> -p <password> [-r <#rounds>]\n\n", argv[0]);

  0006b	b8 04 00 00 00	 mov	 eax, 4
  00070	6b c8 00	 imul	 ecx, eax, 0
  00073	8b 55 08	 mov	 edx, DWORD PTR _argv$[ebp]
  00076	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMke@
  0007f	e8 00 00 00 00	 call	 _printf
  00084	83 c4 08	 add	 esp, 8

; 262  : 
; 263  : 	printf("-e filename		:encrypt the specified file\n");

  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5speci@
  0008c	e8 00 00 00 00	 call	 _printf
  00091	83 c4 04	 add	 esp, 4

; 264  : 	printf("-d filename		:decrypt the specified file\n");

  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5speci@
  00099	e8 00 00 00 00	 call	 _printf
  0009e	83 c4 04	 add	 esp, 4

; 265  : 	printf("-p password		:the password to be used for encryption [default='password']\n");

  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5b@
  000a6	e8 00 00 00 00	 call	 _printf
  000ab	83 c4 04	 add	 esp, 4

; 266  : 	printf("-r <#rounds>		:number of encryption rounds (1 - 3)  [default = 1]\n");

  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encryp@
  000b3	e8 00 00 00 00	 call	 _printf
  000b8	83 c4 04	 add	 esp, 4

; 267  : 	printf("-o filename		:name of the output file [default='encrypted.txt' or 'decrypted.txt'\n\n");

  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5outpu@
  000c0	e8 00 00 00 00	 call	 _printf
  000c5	83 c4 04	 add	 esp, 4

; 268  : 	printf("The order of the options is irrelevant.\n\n");

  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irr@
  000cd	e8 00 00 00 00	 call	 _printf
  000d2	83 c4 04	 add	 esp, 4

; 269  : 	exit(0);

  000d5	6a 00		 push	 0
  000d7	e8 00 00 00 00	 call	 _exit
$LN2@usage:

; 270  : } // usage

  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	5b		 pop	 ebx
  000df	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000e5	3b ec		 cmp	 ebp, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
?usage@@YAXQAPAD@Z ENDP					; usage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\gdick\source\repos\assemblyproject\assemblyproject\cryptomain_initial.cpp
;	COMDAT ?openOutputFile@@YAPAU_iobuf@@PAD@Z
_TEXT	SEGMENT
_fptr$ = -8						; size = 4
_filename$ = 8						; size = 4
?openOutputFile@@YAPAU_iobuf@@PAD@Z PROC		; openOutputFile, COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C6F44F76_cryptomain_initial@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 241  : 	FILE *fptr;
; 242  : 
; 243  : 	fptr = fopen(filename, "wb+");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_03BFHAFKOB@wb?$CL@
  0002d	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _fopen
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 f8	 mov	 DWORD PTR _fptr$[ebp], eax

; 244  : 	if (fptr == NULL)

  0003c	83 7d f8 00	 cmp	 DWORD PTR _fptr$[ebp], 0
  00040	75 23		 jne	 SHORT $LN2@openOutput

; 245  : 	{
; 246  : 		fprintf(stderr, "\n\nError - Could not open output file %s!\n\n", filename);

  00042	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output@
  0004b	6a 02		 push	 2
  0004d	e8 00 00 00 00	 call	 ___acrt_iob_func
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _fprintf
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 247  : 		exit(-1);

  0005e	6a ff		 push	 -1
  00060	e8 00 00 00 00	 call	 _exit
$LN2@openOutput:

; 248  : 	}
; 249  : 	return fptr;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _fptr$[ebp]
$LN3@openOutput:

; 250  : } // openOutputFile

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?openOutputFile@@YAPAU_iobuf@@PAD@Z ENDP		; openOutputFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\gdick\source\repos\assemblyproject\assemblyproject\cryptomain_initial.cpp
;	COMDAT ?openInputFile@@YAPAU_iobuf@@PAD@Z
_TEXT	SEGMENT
_sz$ = -20						; size = 4
_fptr$ = -8						; size = 4
_filename$ = 8						; size = 4
?openInputFile@@YAPAU_iobuf@@PAD@Z PROC			; openInputFile, COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C6F44F76_cryptomain_initial@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 214  : 	FILE *fptr;
; 215  : 	long sz;
; 216  : 
; 217  : 	fptr = fopen(filename, "rb");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  0002d	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _fopen
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 f8	 mov	 DWORD PTR _fptr$[ebp], eax

; 218  : 	if (fptr == NULL)

  0003c	83 7d f8 00	 cmp	 DWORD PTR _fptr$[ebp], 0
  00040	75 23		 jne	 SHORT $LN2@openInputF

; 219  : 	{
; 220  : 		fprintf(stderr, "\n\nError - Could not open input file %s!\n\n", filename);

  00042	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5@
  0004b	6a 02		 push	 2
  0004d	e8 00 00 00 00	 call	 ___acrt_iob_func
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _fprintf
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 221  : 		exit(-1);

  0005e	6a ff		 push	 -1
  00060	e8 00 00 00 00	 call	 _exit
$LN2@openInputF:

; 222  : 	}
; 223  : 
; 224  : 	fseek(fptr, 0, SEEK_END);

  00065	6a 02		 push	 2
  00067	6a 00		 push	 0
  00069	8b 45 f8	 mov	 eax, DWORD PTR _fptr$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _fseek
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 225  : 	sz = ftell(fptr);

  00075	8b 45 f8	 mov	 eax, DWORD PTR _fptr$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _ftell
  0007e	83 c4 04	 add	 esp, 4
  00081	89 45 ec	 mov	 DWORD PTR _sz$[ebp], eax

; 226  : 	fseek(fptr, 0, SEEK_SET);

  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	8b 45 f8	 mov	 eax, DWORD PTR _fptr$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _fseek
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 227  : 
; 228  : 	if (sz == 0)

  00094	83 7d ec 00	 cmp	 DWORD PTR _sz$[ebp], 0
  00098	75 47		 jne	 SHORT $LN3@openInputF

; 229  : 	{
; 230  : 		fprintf(stderr, "Error - File size is zero for \"%s\".\n\n", filename);

  0009a	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0009d	50		 push	 eax
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NACGJJHN@Error?5?9?5File?5size?5is?5zero?5for?5?$CC@
  000a3	6a 02		 push	 2
  000a5	e8 00 00 00 00	 call	 ___acrt_iob_func
  000aa	83 c4 04	 add	 esp, 4
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 _fprintf
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 231  : 		fprintf(stderr, "Aborting operation - try again!\n\n");

  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@ECEBOFML@Aborting?5operation?5?9?5try?5again?$CB@
  000bb	6a 02		 push	 2
  000bd	e8 00 00 00 00	 call	 ___acrt_iob_func
  000c2	83 c4 04	 add	 esp, 4
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _fprintf
  000cb	83 c4 08	 add	 esp, 8

; 232  : 		fclose(fptr);

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _fptr$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _fclose
  000d7	83 c4 04	 add	 esp, 4

; 233  : 		exit(0);

  000da	6a 00		 push	 0
  000dc	e8 00 00 00 00	 call	 _exit
$LN3@openInputF:

; 234  : 	}
; 235  : 
; 236  : 	return fptr;

  000e1	8b 45 f8	 mov	 eax, DWORD PTR _fptr$[ebp]
$LN4@openInputF:

; 237  : } // openInputFile

  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000ed	3b ec		 cmp	 ebp, esp
  000ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
?openInputFile@@YAPAU_iobuf@@PAD@Z ENDP			; openInputFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\gdick\source\repos\assemblyproject\assemblyproject\cryptomain_initial.cpp
;	COMDAT ?decryptFile@@YAHPAU_iobuf@@0@Z
_TEXT	SEGMENT
_filesize$ = -20					; size = 4
_buffer$ = -8						; size = 4
_fptrIn$ = 8						; size = 4
_fptrOut$ = 12						; size = 4
?decryptFile@@YAHPAU_iobuf@@0@Z PROC			; decryptFile, COMDAT

; 181  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C6F44F76_cryptomain_initial@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 182  : 	char *buffer;
; 183  : 	unsigned int filesize;
; 184  : 
; 185  : 	fseek(fptrIn, 0, SEEK_END);

  00028	6a 02		 push	 2
  0002a	6a 00		 push	 0
  0002c	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _fseek
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 186  : 	filesize = ftell(fptrIn);

  00038	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _ftell
  00041	83 c4 04	 add	 esp, 4
  00044	89 45 ec	 mov	 DWORD PTR _filesize$[ebp], eax

; 187  : 	fseek(fptrIn, 0, SEEK_SET);

  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _fseek
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 188  : 
; 189  : 	if (filesize > 0x1000000)					// 16 MB, file too large

  00057	81 7d ec 00 00
	00 01		 cmp	 DWORD PTR _filesize$[ebp], 16777216 ; 01000000H
  0005e	76 20		 jbe	 SHORT $LN2@decryptFil

; 190  : 	{
; 191  : 		fprintf(stderr, "Error - Input file to decrypt is too large.\n\n");

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@NGFEABL@Error?5?9?5Input?5file?5to?5decrypt?5i@
  00065	6a 02		 push	 2
  00067	e8 00 00 00 00	 call	 ___acrt_iob_func
  0006c	83 c4 04	 add	 esp, 4
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _fprintf
  00075	83 c4 08	 add	 esp, 8

; 192  : 		return -1;

  00078	83 c8 ff	 or	 eax, -1
  0007b	e9 80 00 00 00	 jmp	 $LN1@decryptFil
$LN2@decryptFil:

; 193  : 	}
; 194  : 
; 195  : 	// use the password hash to encrypt
; 196  : 	buffer = (char *)malloc(filesize);

  00080	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _malloc
  00089	83 c4 04	 add	 esp, 4
  0008c	89 45 f8	 mov	 DWORD PTR _buffer$[ebp], eax

; 197  : 	if (buffer == NULL)

  0008f	83 7d f8 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00093	75 21		 jne	 SHORT $LN3@decryptFil

; 198  : 	{
; 199  : 		fprintf(stderr, "Error - Could not allocate %d bytes of memory on the heap.\n\n", filesize);

  00095	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  00098	50		 push	 eax
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5b@
  0009e	6a 02		 push	 2
  000a0	e8 00 00 00 00	 call	 ___acrt_iob_func
  000a5	83 c4 04	 add	 esp, 4
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _fprintf
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 200  : 		return -1;

  000b1	83 c8 ff	 or	 eax, -1
  000b4	eb 4a		 jmp	 SHORT $LN1@decryptFil
$LN3@decryptFil:

; 201  : 	}
; 202  : 
; 203  : 	fread(buffer, 1, filesize, fptrIn);	// read entire file

  000b6	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _filesize$[ebp]
  000bd	51		 push	 ecx
  000be	6a 01		 push	 1
  000c0	8b 55 f8	 mov	 edx, DWORD PTR _buffer$[ebp]
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _fread
  000c9	83 c4 10	 add	 esp, 16			; 00000010H

; 204  : 	decryptData(buffer, filesize);

  000cc	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  000cf	50		 push	 eax
  000d0	8b 4d f8	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ?decryptData@@YAHPADH@Z	; decryptData
  000d9	83 c4 08	 add	 esp, 8

; 205  : 	fwrite(buffer, 1, filesize, fptrOut);

  000dc	8b 45 0c	 mov	 eax, DWORD PTR _fptrOut$[ebp]
  000df	50		 push	 eax
  000e0	8b 4d ec	 mov	 ecx, DWORD PTR _filesize$[ebp]
  000e3	51		 push	 ecx
  000e4	6a 01		 push	 1
  000e6	8b 55 f8	 mov	 edx, DWORD PTR _buffer$[ebp]
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 _fwrite
  000ef	83 c4 10	 add	 esp, 16			; 00000010H

; 206  : 	free(buffer);

  000f2	8b 45 f8	 mov	 eax, DWORD PTR _buffer$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _free
  000fb	83 c4 04	 add	 esp, 4

; 207  : 
; 208  : 	return 0;

  000fe	33 c0		 xor	 eax, eax
$LN1@decryptFil:

; 209  : } // decryptFile

  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00109	3b ec		 cmp	 ebp, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
?decryptFile@@YAHPAU_iobuf@@0@Z ENDP			; decryptFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\gdick\source\repos\assemblyproject\assemblyproject\cryptomain_initial.cpp
;	COMDAT ?encryptFile@@YAHPAU_iobuf@@0@Z
_TEXT	SEGMENT
_filesize$ = -20					; size = 4
_buffer$ = -8						; size = 4
_fptrIn$ = 8						; size = 4
_fptrOut$ = 12						; size = 4
?encryptFile@@YAHPAU_iobuf@@0@Z PROC			; encryptFile, COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C6F44F76_cryptomain_initial@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 149  : 	char *buffer;
; 150  : 	unsigned int filesize;
; 151  : 
; 152  : 	fseek(fptrIn, 0, SEEK_END);

  00028	6a 02		 push	 2
  0002a	6a 00		 push	 0
  0002c	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _fseek
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 153  : 	filesize = ftell(fptrIn);

  00038	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _ftell
  00041	83 c4 04	 add	 esp, 4
  00044	89 45 ec	 mov	 DWORD PTR _filesize$[ebp], eax

; 154  : 	fseek(fptrIn, 0, SEEK_SET);

  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _fseek
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 155  : 
; 156  : 	if (filesize > 0x1000000)					// 16 MB, file too large

  00057	81 7d ec 00 00
	00 01		 cmp	 DWORD PTR _filesize$[ebp], 16777216 ; 01000000H
  0005e	76 20		 jbe	 SHORT $LN2@encryptFil

; 157  : 	{
; 158  : 		fprintf(stderr, "Error - Input file to encrypt is too large.\n\n");

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@PKBMFPCH@Error?5?9?5Input?5file?5to?5encrypt?5i@
  00065	6a 02		 push	 2
  00067	e8 00 00 00 00	 call	 ___acrt_iob_func
  0006c	83 c4 04	 add	 esp, 4
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _fprintf
  00075	83 c4 08	 add	 esp, 8

; 159  : 		return -1;

  00078	83 c8 ff	 or	 eax, -1
  0007b	e9 80 00 00 00	 jmp	 $LN1@encryptFil
$LN2@encryptFil:

; 160  : 	}
; 161  : 
; 162  : 	// use the password hash to encrypt
; 163  : 	buffer = (char *)malloc(filesize);

  00080	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _malloc
  00089	83 c4 04	 add	 esp, 4
  0008c	89 45 f8	 mov	 DWORD PTR _buffer$[ebp], eax

; 164  : 	if (buffer == NULL)

  0008f	83 7d f8 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00093	75 21		 jne	 SHORT $LN3@encryptFil

; 165  : 	{
; 166  : 		fprintf(stderr, "Error - Could not allocate %d bytes of memory on the heap.\n\n", filesize);

  00095	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  00098	50		 push	 eax
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5b@
  0009e	6a 02		 push	 2
  000a0	e8 00 00 00 00	 call	 ___acrt_iob_func
  000a5	83 c4 04	 add	 esp, 4
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _fprintf
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : 		return -1;

  000b1	83 c8 ff	 or	 eax, -1
  000b4	eb 4a		 jmp	 SHORT $LN1@encryptFil
$LN3@encryptFil:

; 168  : 	}
; 169  : 
; 170  : 	fread(buffer, 1, filesize, fptrIn);	// read entire file

  000b6	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _filesize$[ebp]
  000bd	51		 push	 ecx
  000be	6a 01		 push	 1
  000c0	8b 55 f8	 mov	 edx, DWORD PTR _buffer$[ebp]
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _fread
  000c9	83 c4 10	 add	 esp, 16			; 00000010H

; 171  : 	encryptData(buffer, filesize);

  000cc	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  000cf	50		 push	 eax
  000d0	8b 4d f8	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ?encryptData@@YAHPADH@Z	; encryptData
  000d9	83 c4 08	 add	 esp, 8

; 172  : 	fwrite(buffer, 1, filesize, fptrOut);

  000dc	8b 45 0c	 mov	 eax, DWORD PTR _fptrOut$[ebp]
  000df	50		 push	 eax
  000e0	8b 4d ec	 mov	 ecx, DWORD PTR _filesize$[ebp]
  000e3	51		 push	 ecx
  000e4	6a 01		 push	 1
  000e6	8b 55 f8	 mov	 edx, DWORD PTR _buffer$[ebp]
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 _fwrite
  000ef	83 c4 10	 add	 esp, 16			; 00000010H

; 173  : 	free(buffer);

  000f2	8b 45 f8	 mov	 eax, DWORD PTR _buffer$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _free
  000fb	83 c4 04	 add	 esp, 4

; 174  : 
; 175  : 	return 0;

  000fe	33 c0		 xor	 eax, eax
$LN1@encryptFil:

; 176  : } // encryptFile

  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00109	3b ec		 cmp	 ebp, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
?encryptFile@@YAHPAU_iobuf@@0@Z ENDP			; encryptFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\gdick\source\repos\assemblyproject\assemblyproject\cryptomain_initial.cpp
;	COMDAT ?exCountLetters@@YAXPADHPAH11@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
_numC$ = 16						; size = 4
_numL$ = 20						; size = 4
_numO$ = 24						; size = 4
?exCountLetters@@YAXPADHPAH11@Z PROC			; exCountLetters, COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 69   : 	__asm {
; 70   : 		cld;					// 

  0001e	fc		 cld

; 71   : 		push esi;				// 

  0001f	56		 push	 esi

; 72   : 		push ecx;				// 

  00020	51		 push	 ecx

; 73   : 		push ebx;

  00021	53		 push	 ebx

; 74   : 		mov esi, data;			// 

  00022	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]

; 75   : 		mov ecx, dataLength;	// 

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _dataLength$[ebp]
$LOOP_X1$3:

; 76   : 
; 77   : 	LOOP_X1:
; 78   : 		lodsb;					// 

  00028	ac		 lodsb

; 79   : 		mov bl, al				// 

  00029	8a d8		 mov	 bl, al

; 80   : 			push eax;				// 

  0002b	50		 push	 eax

; 81   : 		call isLetter;			// function returns a 1 in al if the character passed in is a letter, otherwise al = 0

  0002c	e8 2b 00 00 00	 call	 $isLetter$4

; 82   : 		add esp, 4				// 

  00031	83 c4 04	 add	 esp, 4

; 83   : 			test al, al;				// 

  00034	84 c0		 test	 al, al

; 84   : 		je lbl_OTHER;			// 

  00036	74 16		 je	 SHORT $lbl_OTHER$5

; 85   : 
; 86   : 		mov al, bl				// 

  00038	8a c3		 mov	 al, bl

; 87   : 			and al, 0x20;			// already know it's a letter, if al == 0, then CAP

  0003a	24 20		 and	 al, 32			; 00000020H

; 88   : 		je lbl_CAP;

  0003c	74 08		 je	 SHORT $lbl_CAP$6

; 89   : 
; 90   : 		mov	ebx, numL;			// 

  0003e	8b 5d 14	 mov	 ebx, DWORD PTR _numL$[ebp]

; 91   : 		add[ebx], 1;			// 

  00041	80 03 01	 add	 BYTE PTR [ebx], 1

; 92   : 		jmp lbl_NEXT;			// 

  00044	eb 0e		 jmp	 SHORT $lbl_NEXT$7
$lbl_CAP$6:

; 93   : 
; 94   : 	lbl_CAP:
; 95   : 		mov ebx, numC;			// 

  00046	8b 5d 10	 mov	 ebx, DWORD PTR _numC$[ebp]

; 96   : 		add[ebx], 1;			// 

  00049	80 03 01	 add	 BYTE PTR [ebx], 1

; 97   : 		jmp lbl_NEXT;			// 

  0004c	eb 06		 jmp	 SHORT $lbl_NEXT$7
$lbl_OTHER$5:

; 98   : 
; 99   : 	lbl_OTHER:
; 100  : 		mov ebx, numO			// 

  0004e	8b 5d 18	 mov	 ebx, DWORD PTR _numO$[ebp]

; 101  : 			add[ebx], 1				// 

  00051	80 03 01	 add	 BYTE PTR [ebx], 1
$lbl_NEXT$7:

; 102  : 			lbl_NEXT :
; 103  : 			dec ecx;				// 

  00054	49		 dec	 ecx

; 104  : 		jne LOOP_X1;			// 

  00055	75 d1		 jne	 SHORT $LOOP_X1$3

; 105  : 
; 106  : 		pop ebx;				// 

  00057	5b		 pop	 ebx

; 107  : 		pop ecx;				// 

  00058	59		 pop	 ecx

; 108  : 		pop esi;				// 

  00059	5e		 pop	 esi

; 109  : 		jmp EXIT_C_EXAMPLE;		// let C handle whatever it did upon entering this function

  0005a	eb 25		 jmp	 SHORT $EXIT_C_EXAMPLE$8
$isLetter$4:

; 110  : 
; 111  : 	isLetter:
; 112  : 		push ebp;				// 

  0005c	55		 push	 ebp

; 113  : 		mov ebp, esp;			// 

  0005d	8b ec		 mov	 ebp, esp

; 114  : 		mov al, [ebp + 8];			// 

  0005f	8a 45 08	 mov	 al, BYTE PTR [ebp+8]

; 115  : 		cmp al, 0x40;			// 

  00062	3c 40		 cmp	 al, 64			; 00000040H

; 116  : 		ja lbl_CHK_ZU;			// check Uppercase 'Z'

  00064	77 0d		 ja	 SHORT $lbl_CHK_ZU$9
$lbl_RET_FALSE$10:

; 117  : 
; 118  : 	lbl_RET_FALSE:
; 119  : 		xor eax, eax;			// 

  00066	33 c0		 xor	 eax, eax
$lbl_RET$11:

; 120  : 	lbl_RET:
; 121  : 		mov esp, ebp;			// 

  00068	8b e5		 mov	 esp, ebp

; 122  : 		pop ebp;				// 

  0006a	5d		 pop	 ebp

; 123  : 		ret;					// 

  0006b	c3		 ret	 0
$lbl_RET_TRUE$12:

; 124  : 
; 125  : 	lbl_RET_TRUE:
; 126  : 		mov eax, 1;				// 

  0006c	b8 01 00 00 00	 mov	 eax, 1

; 127  : 		jmp lbl_RET;			// 

  00071	eb f5		 jmp	 SHORT $lbl_RET$11
$lbl_CHK_ZU$9:

; 128  : 
; 129  : 	lbl_CHK_ZU:
; 130  : 		cmp al, 0x5B;			// 

  00073	3c 5b		 cmp	 al, 91			; 0000005bH

; 131  : 		jb lbl_RET_TRUE;		// 

  00075	72 f5		 jb	 SHORT $lbl_RET_TRUE$12

; 132  : 
; 133  : 		cmp al, 0x61;			// 

  00077	3c 61		 cmp	 al, 97			; 00000061H

; 134  : 		jb lbl_RET_FALSE;		// check lowercase 'z'

  00079	72 eb		 jb	 SHORT $lbl_RET_FALSE$10

; 135  : 
; 136  : 		cmp al, 0x7A;			// 

  0007b	3c 7a		 cmp	 al, 122			; 0000007aH

; 137  : 		jbe lbl_RET_TRUE;		// 

  0007d	76 ed		 jbe	 SHORT $lbl_RET_TRUE$12

; 138  : 		jmp lbl_RET_FALSE;		// 

  0007f	eb e5		 jmp	 SHORT $lbl_RET_FALSE$10
$EXIT_C_EXAMPLE$8:

; 139  : 
; 140  : 	} // end assembly block
; 141  : 
; 142  : EXIT_C_EXAMPLE:					// 
; 143  : 	return;
; 144  : } // exCountLetters

  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?exCountLetters@@YAXPADHPAH11@Z ENDP			; exCountLetters
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __A452D4A0_stdio@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

  00028	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0002b	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0002e	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00031	50		 push	 eax
  00032	6a 00		 push	 0
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00037	51		 push	 ecx
  00038	6a 01		 push	 1
  0003a	e8 00 00 00 00	 call	 ___acrt_iob_func
  0003f	83 c4 04	 add	 esp, 4
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 __vfprintf_l
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

  0004e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

  00055	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 961  :     }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __A452D4A0_stdio@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

  00028	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0002b	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0002e	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00031	50		 push	 eax
  00032	6a 00		 push	 0
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __Stream$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 __vfprintf_l
  00041	83 c4 10	 add	 esp, 16			; 00000010H
  00044	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

  00047	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 842  :     }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __A452D4A0_stdio@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00028	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	51		 push	 ecx
  00041	8b 10		 mov	 edx, DWORD PTR [eax]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00049	83 c4 18	 add	 esp, 24			; 00000018H

; 644  :     }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00028	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
