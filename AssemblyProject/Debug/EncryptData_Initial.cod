; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\gdick\source\repos\AssemblyProject\AssemblyProject\EncryptData_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__2088847F_corecrt_memory@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__E9FFF232_guiddef@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__12AD47BB_winuser@h DB 01H
__B4B40122_winioctl@h DB 01H
__A73354DD_stdlib@h DB 01H
__25F3FB34_propidl@h DB 01H
__A40E48B8_oleauto@h DB 01H
__86261D59_stralign@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__F0CC4AC4_corecrt_wio@h DB 01H
__014F4607_corecrt_io@h DB 01H
__3D2204A7_encryptdata_initial@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?encryptData@@YAHPADH@Z				; encryptData
PUBLIC	__JustMyCode_Default
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?gkey@@3PAEA:BYTE				; gkey
EXTRN	?gPasswordHash@@3PAEA:BYTE			; gPasswordHash
EXTRN	?gdebug1@@3EA:BYTE				; gdebug1
EXTRN	?gdebug2@@3EA:BYTE				; gdebug2
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\gdick\source\repos\assemblyproject\assemblyproject\encryptdata_initial.cpp
;	COMDAT ?encryptData@@YAHPADH@Z
_TEXT	SEGMENT
_resulti$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
?encryptData@@YAHPADH@Z PROC				; encryptData, COMDAT

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 12   : 	int resulti = 0;

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _resulti$[ebp], 0

; 13   : 
; 14   : 	gdebug1 = 0;					// a couple of global variables that could be used for debugging

  0002f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug1@@3EA, 0 ; gdebug1

; 15   : 	gdebug2 = 0;					// also can have a breakpoint in C code

  00036	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug2@@3EA, 0 ; gdebug2

; 16   : 
; 17   : 	// You can not declare any local variables in C, but should use resulti to indicate any errors
; 18   : 	// Set up the stack frame and assign variables in assembly if you need to do so
; 19   : 	// access the parameters BEFORE setting up your own stack frame
; 20   : 	// Also, you cannot use a lot of global variables - work with registers
; 21   : 
; 22   : 	__asm {
; 23   : 		lea esi, gPasswordHash

  0003d	8d 35 00 00 00
	00		 lea	 esi, OFFSET ?gPasswordHash@@3PAEA

; 24   : 		xor eax, eax

  00043	33 c0		 xor	 eax, eax

; 25   : 		mov ah, [esi]

  00045	8a 26		 mov	 ah, BYTE PTR [esi]

; 26   : 		mov al, [esi + 1]

  00047	8a 46 01	 mov	 al, BYTE PTR [esi+1]

; 27   : 
; 28   : 		lea edi, gkey

  0004a	8d 3d 00 00 00
	00		 lea	 edi, OFFSET ?gkey@@3PAEA

; 29   : 		mov bl, [edi + eax]

  00050	8a 1c 07	 mov	 bl, BYTE PTR [edi+eax]

; 30   : 		xor ebx, ebx

  00053	33 db		 xor	 ebx, ebx

; 31   : 		xor ecx, ecx

  00055	33 c9		 xor	 ecx, ecx

; 32   : 		mov ecx, dataLength

  00057	8b 4d 0c	 mov	 ecx, DWORD PTR _dataLength$[ebp]

; 33   : 		cmp ecx, 0

  0005a	83 f9 00	 cmp	 ecx, 0

; 34   : 		sub ecx, 1

  0005d	83 e9 01	 sub	 ecx, 1

; 35   : 		jbe LENGTH_ZERO

  00060	76 0f		 jbe	 SHORT $LENGTH_ZERO$3
$START_OF_LOOP$4:

; 36   : 
; 37   : 		START_OF_LOOP :
; 38   : 		mov al, [esi + ebx]

  00062	8a 04 1e	 mov	 al, BYTE PTR [esi+ebx]

; 39   : 			xor al, bl

  00065	32 c3		 xor	 al, bl

; 40   : 			mov[esi + ebx], al

  00067	88 04 1e	 mov	 BYTE PTR [esi+ebx], al

; 41   : 
; 42   : 			inc ebx

  0006a	43		 inc	 ebx

; 43   : 			cmp ebx, ecx

  0006b	3b d9		 cmp	 ebx, ecx

; 44   : 			je  END

  0006d	74 09		 je	 SHORT $END$5

; 45   : 			jmp START_OF_LOOP

  0006f	eb f1		 jmp	 SHORT $START_OF_LOOP$4
$LENGTH_ZERO$3:

; 46   : 
; 47   : 			LENGTH_ZERO :
; 48   : 		mov ebx, -1

  00071	bb ff ff ff ff	 mov	 ebx, -1

; 49   : 			jmp EXIT

  00076	eb 02		 jmp	 SHORT $EXIT$6
$END$5:

; 50   : 
; 51   : 			END :
; 52   : 		xor ebx, ebx

  00078	33 db		 xor	 ebx, ebx
$EXIT$6:

; 53   : 			EXIT :
; 54   : 		mov resulti, ebx

  0007a	89 5d f4	 mov	 DWORD PTR _resulti$[ebp], ebx

; 55   : 	}
; 56   : 
; 57   : 	return resulti;

  0007d	8b 45 f4	 mov	 eax, DWORD PTR _resulti$[ebp]

; 58   : } // encryptData

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00086	33 cd		 xor	 ecx, ebp
  00088	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008d	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
?encryptData@@YAHPADH@Z ENDP				; encryptData
_TEXT	ENDS
END
