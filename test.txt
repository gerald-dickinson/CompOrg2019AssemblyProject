// EncryptData.cpp
//
// This file uses the input data and key information to encrypt the input data
//

#include "Main.h"

//////////////////////////////////////////////////////////////////////////////////////////////////
// code to encrypt the data as specified by the project assignment
int encryptData(char *data, int dataLength)
{
	int resulti = 0;

	gdebug1 = 0;					// a couple of global variables that could be used for debugging
	gdebug2 = 0;					// also can have a breakpoint in C code

	// You can not declare any local variables in C, but should use resulti to indicate any errors
	// Set up the stack frame and assign variables in assembly if you need to do so
	// access the parameters BEFORE setting up your own stack frame
	// Also, you cannot use a lot of global variables - work with registers

	__asm {

		mov esi, gptrPasswordHash	//gPtrPasswordHash
		xor eax, eax		//set eax to 0
		mov ah, [esi]		//gPasswordHas[0] is in ah
		mov al, [esi + 1]	//gPasswordHash[1] is in al
		

		mov edi, gptrKey
		
		xor ebx, ebx
		xor ecx, ecx

		mov ecx, dataLength
		xor edx, edx
		cmp ecx, 0
		sub ecx, 1
		jbe LENGTH_ZERO
		mov esi, data
		mov dl, [edi+eax]
START_OF_LOOP :
		mov al, [esi + ebx]
		xor dl, al
		push edx

		call Dstep
		call Estep
		call Bstep
		call Astep
		call Cstep
		mov[esi + ebx], al
		add ebx, 1
		cmp ebx, ecx
		ja  END
		jmp START_OF_LOOP
	Dstep:
		push ebp
			mov ebp, esp
	Estep:
		push ebp
			mov ebp, esp
	Bstep:
		push ebp
		mov ebp, esp
		push eax
		mov al, byte ptr[ebp + 8]
		xor al, 01001001b   //invert bits 0,3,6
		move byte ptr[ebp + 8], al
		pop eax
		pop ebp
		ret

	Astep:
		push ebp
		mov ebp, esp
		push eax
		push ebx
		push ecx
		xor eax, eax
		xor ecx, ecx
		xor ebx, ebx
		movz eax, byte ptr[ebp+8]
		jmp LoopBit
	LoopBit :
		shl al, 1
		rcr cl, 1
		cmp ebx, 7
		je EndLoop     // if counter is 7 end the loop
		inc ebx      // else increment count
		jmp LoopBit    // and keep looping
	EndLoop :
		mov byte ptr[ebp + 8], cl
		pop ecx
		pop ebx
		pop eax
		pop ebp
		ret

	Cstep:
		push ebp
		mov ebp, esp
		push eax
		push ecx
		push ebx
		push edx
		push esi
		push edi
		xor eax, eax	
		xor ecx, ecx
		xor ebx, ebx
		xor edx, edx
		xor edi, edi
		movzx esi, byte ptr[ebp+8]
		mov eax, esi
		jmp Looper1
	Looper1 :
			shr eax, 1
			rcr ecx, 1
			add ebx, 1
			cmp ebx, 1
			ja MOVE
			jmp Looper1
	MOVE :
			mov edx, ecx
			mov ecx, 0
			mov edi, 0
			jmp SHIFT_OTHER
	SHIFT_OTHER :
			shr eax, 1
			rcr ecx, 1
			add edi, 1
			cmp edi, 1
			ja OVER
			jmp SHIFT_OTHER
	OVER :
			mov edi, 0
			shr ecx, 2
			add ecx, edx
			xchg edx, ecx
			mov eax, esi
			mov ecx, 0
			shr eax, 4
			jmp Loop2
	Loop2 :
			shr eax, 1
			rcr ecx, 1
			add edi, 1
			cmp edi, 1
			ja EXIT2
			jmp Loop2
	EXIT2 :
			mov ebx, ecx
			mov ecx, 0
			mov edi, 0
			jmp Loop3
	Loop3 :
			shr eax, 1
			rcr ecx, 1
			add edi, 1
			cmp edi, 1
			ja END3
			jmp Loop3
	END3 :
			ror ecx, 2
			add ecx, ebx
			shr edx, 16
			shr edx, 12
			shr ecx, 16
			shr ecx, 8
			add ecx, edx

			mov eax, ecx
			mov byte ptr[ebp+8], al
			pop edi
			pop esi
			pop edx
			pop ebx
			pop ecx
			pop eax
			pop ebp
			ret

LENGTH_ZERO :
		sub ebx, 1
		jmp EXIT
END :
		xor ebx, ebx
EXIT :
		mov resulti, ebx
	}
	return resulti;
} // encryptData