Dstep :
			push ebp
			mov ebp, esp
			push eax
			xor eax, eax
			mov al, dl
			ror al, 3
			mov dl, al
			mov [ebp+8], edx
			pop eax
			mov esp, ebp
			pop ebp
			ret
Estep :
			push ebp
			mov ebp, esp
			push eax
			push ebx
			push esi
			xor eax, eax
			lea esi, gEncodeTable
			mov al, dl
			mov bl, [esi + eax]	//
			mov dl, bl
			mov byte ptr[ebp + 8], dl
			pop esi
			pop ebx
			pop eax
			mov esp, ebp
			pop ebp
			ret
Bstep :
			push ebp
			mov ebp, esp
			push eax
			xor eax, eax
			mov al, dl	//store hex value into al
			xor al, 01001001b   //invert bits 0,3,6
			mov dl, al	//insert new value back into place 
			mov byte ptr[ebp + 8], dl
			pop eax
		mov esp, ebp
			pop ebp
			ret					//return to previous position
Astep :
			push ebp
			mov ebp, esp
			push eax
			push ebx
			push ecx
			push edi
			mov edi, 0		//clear eax
			mov ecx, 0		//clear ecx
			mov al, byte ptr[ebp+8]	//move & zero extend value at ebp+8 into eax
			jmp reverse_bit			//jump to LoopBit function

reverse_bit:

			shl al, 1		//shift al left by 1
			rcr cl, 1		//rotate and carry cl by 1
			cmp edi, 7
			je reverse_comp     // if counter is 7 end the loop
			inc edi     // else increment count
			jmp reverse_bit    // and keep looping

reverse_comp :

			mov dl, cl	//move cl into ebp+8
			mov byte ptr[ebp + 8], cl
			pop edi
			pop ecx
			pop ebx
			pop eax
			mov edi, gptrKey
			mov esp, ebp
			pop ebp
			ret			//return to previous position
Cstep :
			push ebp
			mov ebp, esp
			push eax
			push ebx
			push ecx
			push esi
			push edi
			xor ecx, ecx
			xor eax, eax
			xor edx, edx
			xor ebx, ebx
			xor edi, edi		//clear edi
			mov esi, [ebp + 8]//move & sign extend value at ebp+8 into esi
			mov eax, esi		//move esi into eax
			jmp Looper1		//jump to Looper1 function
		Looper1 :
			shr eax, 1	//shift eax right by 1
			rcr ecx, 1	//rotate right and carry ecx by 1
			add ebx, 1	//increment ebx by 1
			cmp ebx, 1	//compare ebx to 1
			ja MOVE		//if true jump to MOVE
			jmp Looper1	//else jump to Looper1
		MOVE :
			mov edx, ecx	//move ecx into edx
			mov ecx, 0	//store 0 into ecx
			mov edi, 0	//store 0 into edi
			jmp SHIFT_OTHER	//jump to SHIFT_OTHER function
		SHIFT_OTHER :
			shr eax, 1	//shift eax to the right 1
			rcr ecx, 1	//rotate right and carry edi by 1
			add edi, 1	//increment edi by 1
			cmp edi, 1	//compare edi to 1
			ja OVER		//if true, jump to OVER function
			jmp SHIFT_OTHER	//else jump to SHIFT_OTHER
		OVER :
			mov edi, 0	//store 0 into edi
			shr ecx, 2	//shift ecx to the right by 2
			add ecx, edx	//increment ecx by edx
			xchg edx, ecx	//xchg the register values
			mov eax, esi	//store esi into eax
			mov ecx, 0	//store 0 in ecx
			shr eax, 4	//shift eax right by 4
			jmp Loop2	//jump to Loop2 function
		Loop2 :
			shr eax, 1	//shift eax to the right by 1
			rcr ecx, 1	//rotate right and carry ecx by 1
			add edi, 1	//increment edi by 1
			cmp edi, 1	//compare edi to 1
			ja EXIT2	//if true jump to EXIT2
			jmp Loop2	//else jump to Loop2
		EXIT2 :
			mov ebx, ecx	//move ecx into ebx
			mov ecx, 0	//set ecx to 0
			mov edi, 0	//set edi to 0
			jmp Loop3	//jump to Loop3
		Loop3 :
			shr eax, 1	//shift eax to the right by 1+
			rcr ecx, 1	//rotate right and carry ecx by 1
			add edi, 1	//increment edi by 1
			cmp edi, 1	//compare edi to 1
			ja END3		//jump above END3
			jmp Loop3	//else jump to Loop3
		END3 :
			ror ecx, 2	//rotate ecx right by 2
			add ecx, ebx	//increment ecx by ebx
			shr edx, 16	//shift edx to the right by 16
			shr edx, 12	//shift edx to the right by 12
			shr ecx, 16	//shift ecx to the right by 16
			shr ecx, 8	//shift ecx to the right by 8
			add ecx, edx	//increment ecx by edx
			mov dl, cl	//move al into ebp+
			mov byte ptr [ebp+8], cl
			pop edi
			pop esi
			pop ecx
			pop ebx
			pop eax
			mov esp, ebp
			pop ebp
			ret